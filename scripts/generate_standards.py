#!/usr/bin/env python3
"""
Generate Coding Standards - Database-Driven Standards Generator

Reads coding standards from PostgreSQL database and generates ~/.claude/standards/

Architecture:
    Database (Source of Truth)
        ↓
    generate_standards.py
        ↓
    ~/.claude/standards/ (Generated, do not edit manually)

Directory Structure:
    ~/.claude/standards/
        ├── core/               # Universal standards (file size, documentation, etc.)
        ├── language/           # Language-specific (C#, Python, TypeScript, Rust, etc.)
        ├── framework/          # Framework-specific (MUI, WinForms, WPF, React, etc.)
        └── pattern/            # Design patterns and best practices

Called by:
    - session_startup_hook.py on every SessionStart (self-healing)
    - Manual: python scripts/generate_standards.py

Author: Claude Family
Date: 2026-01-02
"""

import json
import os
import sys
import logging
from pathlib import Path
from typing import Dict, List, Optional

# Setup logging
LOG_FILE = Path.home() / ".claude" / "hooks.log"
LOG_FILE.parent.mkdir(exist_ok=True)

logging.basicConfig(
    filename=str(LOG_FILE),
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger('standards_generator')

# Shared credential loading
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from config import get_db_connection, detect_psycopg
_psycopg_mod, PSYCOPG_VERSION, _, _ = detect_psycopg()
DB_AVAILABLE = _psycopg_mod is not None


def get_all_standards(conn) -> List[Dict]:
    """Get all active coding standards from database."""
    try:
        cur = conn.cursor()
        cur.execute("""
            SELECT
                standard_id,
                category,
                name,
                file_path,
                content,
                applies_to_patterns,
                validation_rules,
                priority,
                description
            FROM claude.coding_standards
            WHERE active = true
            ORDER BY category, priority, name
        """)

        results = cur.fetchall()
        return [dict(r) if PSYCOPG_VERSION == 3 else dict(r) for r in results]

    except Exception as e:
        logger.error(f"Failed to get standards: {e}")
        return []


def generate_standards_files(standards: List[Dict], output_dir: Path) -> bool:
    """Generate standards files in ~/.claude/standards/

    Args:
        standards: List of standard dictionaries from database
        output_dir: Base directory for standards (e.g., ~/.claude/standards/)

    Returns:
        True if successful, False otherwise
    """
    try:
        # Create base directory
        output_dir.mkdir(parents=True, exist_ok=True)

        # Create category directories
        for category in ['core', 'language', 'framework', 'pattern']:
            (output_dir / category).mkdir(exist_ok=True)

        # Generate each standard file
        files_generated = 0
        for standard in standards:
            file_path = output_dir / standard['file_path']
            content = standard['content']

            # Ensure parent directory exists
            file_path.parent.mkdir(parents=True, exist_ok=True)

            # Add database metadata header
            header = f"""<!--
Generated from claude.coding_standards database
Standard ID: {standard['standard_id']}
Category: {standard['category']}
Description: {standard.get('description', 'N/A')}
Applies to: {', '.join(standard.get('applies_to_patterns', []))}
Priority: {standard.get('priority', 100)}

DO NOT EDIT THIS FILE DIRECTLY
Edit the database record and regenerate using:
    python scripts/generate_standards.py
-->

"""

            full_content = header + content

            # Write file
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(full_content)

            files_generated += 1
            logger.info(f"Generated: {file_path}")

        logger.info(f"Successfully generated {files_generated} standard files")
        return True

    except Exception as e:
        logger.error(f"Failed to generate standards files: {e}", exc_info=True)
        return False


def generate_index_file(standards: List[Dict], output_dir: Path) -> bool:
    """Generate README.md index of all standards."""
    try:
        readme_path = output_dir / "README.md"

        lines = []
        lines.append("# Claude Code Coding Standards")
        lines.append("")
        lines.append("**Generated from database**: `claude.coding_standards`")
        lines.append("")
        lines.append("These standards are automatically loaded via CLAUDE.md @import directives and enforced via PreToolUse validation hooks.")
        lines.append("")
        lines.append("## Available Standards")
        lines.append("")

        # Group by category
        by_category = {}
        for s in standards:
            category = s['category']
            if category not in by_category:
                by_category[category] = []
            by_category[category].append(s)

        for category in ['core', 'language', 'framework', 'pattern']:
            if category not in by_category:
                continue

            lines.append(f"### {category.title()}")
            lines.append("")

            for standard in by_category[category]:
                name = standard['name']
                file_path = standard['file_path']
                description = standard.get('description', '')
                patterns = ', '.join(standard.get('applies_to_patterns', []))

                lines.append(f"- **{name}** - `{file_path}`")
                if description:
                    lines.append(f"  - {description}")
                if patterns:
                    lines.append(f"  - Applies to: `{patterns}`")
                lines.append("")

        lines.append("## Usage")
        lines.append("")
        lines.append("### In CLAUDE.md")
        lines.append("")
        lines.append("```markdown")
        lines.append("# Project CLAUDE.md")
        lines.append("")
        lines.append("@~/.claude/standards/core/markdown-documentation.md")
        lines.append("@~/.claude/standards/language/csharp.md")
        lines.append("@~/.claude/standards/framework/winforms.md")
        lines.append("```")
        lines.append("")
        lines.append("### PreToolUse Validation")
        lines.append("")
        lines.append("Standards are enforced via `scripts/instruction_matcher.py` (PreToolUse hook) which:")
        lines.append("1. Matches file patterns against `applies_to_patterns`")
        lines.append("2. Validates proposed file content against `validation_rules`")
        lines.append("3. Blocks with helpful error if violations found (exit code 2)")
        lines.append("")
        lines.append("## Maintenance")
        lines.append("")
        lines.append("**Add/Edit Standards**: Update `claude.coding_standards` table")
        lines.append("")
        lines.append("```sql")
        lines.append("INSERT INTO claude.coding_standards (")
        lines.append("    category, name, file_path, content, applies_to_patterns, validation_rules")
        lines.append(") VALUES (")
        lines.append("    'language', 'rust', 'language/rust.md', '...', ARRAY['**/*.rs'], '{}'::jsonb")
        lines.append(");")
        lines.append("```")
        lines.append("")
        lines.append("**Regenerate Files**: `python scripts/generate_standards.py`")
        lines.append("")
        lines.append("---")
        lines.append("")
        lines.append(f"**Generated**: {standards[0]['category'] if standards else 'N/A'}")
        lines.append(f"**Standards Count**: {len(standards)}")

        with open(readme_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))

        logger.info(f"Generated index: {readme_path}")
        return True

    except Exception as e:
        logger.error(f"Failed to generate index: {e}", exc_info=True)
        return False


def sync_standards() -> bool:
    """Main entry point: Generate all standards files from database.

    Returns:
        True if successful, False otherwise
    """
    if not DB_AVAILABLE:
        logger.error("Database not available - cannot generate standards")
        return False

    conn = get_db_connection()
    if not conn:
        logger.error("Failed to connect to database")
        return False

    try:
        logger.info("=== Standards Generation Started ===")

        # Get all standards from database
        standards = get_all_standards(conn)
        conn.close()

        if not standards:
            logger.warning("No active standards found in database")
            return False

        logger.info(f"Found {len(standards)} active standards")

        # Generate files
        output_dir = Path.home() / ".claude" / "standards"
        if not generate_standards_files(standards, output_dir):
            logger.error("Failed to generate standards files")
            return False

        # Generate index
        if not generate_index_file(standards, output_dir):
            logger.warning("Failed to generate index (non-fatal)")

        logger.info("=== Standards Generation Complete ===")
        return True

    except Exception as e:
        logger.error(f"Standards generation failed: {e}", exc_info=True)
        try:
            conn.close()
        except:
            pass
        return False


def main():
    """CLI entry point."""
    print("Generating coding standards from database...")
    print(f"Output directory: {Path.home() / '.claude' / 'standards'}")

    if sync_standards():
        print("[OK] Standards generated successfully")
        print(f"  Check: {Path.home() / '.claude' / 'standards'}")
        print(f"  Logs: {LOG_FILE}")
        return 0
    else:
        print("[FAIL] Failed to generate standards")
        print(f"  Check logs: {LOG_FILE}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
