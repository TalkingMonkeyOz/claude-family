<?xml version="1.0" encoding="UTF-8"?>
<bpmn:definitions xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL"
                  xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI"
                  xmlns:dc="http://www.omg.org/spec/DD/20100524/DC"
                  targetNamespace="http://claude.family/bpmn"
                  id="Definitions_context_budget">

  <bpmn:process id="context_budget_management" name="Context Budget Enforcement: Estimate, Decide, Execute" isExecutable="true">

    <!--
      Models how Claude should manage context budget when executing a batch of tasks.
      Triggered AFTER input_decomposition creates tasks, BEFORE execution begins.

      The process that SHOULD have prevented the 3 context exhaustion crashes:
        - 385 tool calls, 7+ BPMN models created inline, ~1.2M tokens consumed
        - Root cause: no estimation, no delegation, no checkpoints

      Key behaviors:
        1. Classify each task by context weight (heavy/medium/light)
        2. Estimate total context cost vs remaining budget
        3. Choose strategy: direct (with checkpoints), delegate_all, or split_and_delegate
        4. Prepare concise agent instructions (minimize context transfer)
        5. Progressive checkpoints on ALL paths (not just before delegation)
        6. Verify agent results before marking complete

      Heavy task indicators:
        - BPMN XML creation (~600 tokens: 300 read + 300 write)
        - Large file generation (>200 lines)
        - Multi-file refactor (3+ files)
        - Test suite creation (read patterns + write tests)

      Integration: Called by input_decomposition after create_tasks step.
      Implementation: Advisory via CORE_PROTOCOL injection + future PreToolUse hook.
    -->

    <!-- START -->
    <bpmn:startEvent id="start" name="Tasks Created (Post-Decomposition)">
      <bpmn:outgoing>flow_start_to_classify</bpmn:outgoing>
    </bpmn:startEvent>

    <!-- STEP 1: CLASSIFY TASK COMPLEXITY -->
    <bpmn:scriptTask id="classify_tasks" name="[CLAUDE] Classify Task Complexity" scriptFormat="python">
      <bpmn:documentation>For each task in the batch, assign a weight:
- heavy: BPMN creation, large file gen, multi-file refactor, test suites
- medium: single file edit, research with file reads, test writing
- light: simple edit, status update, query, git operation
Count heavy_count, medium_count, light_count.</bpmn:documentation>
      <bpmn:incoming>flow_start_to_classify</bpmn:incoming>
      <bpmn:outgoing>flow_classify_to_estimate</bpmn:outgoing>
      <bpmn:script>
try:
    if task_count is None:
        task_count = 0
except NameError:
    task_count = 0
try:
    if heavy_count is None:
        heavy_count = 0
except NameError:
    heavy_count = 0
try:
    if medium_count is None:
        medium_count = 0
except NameError:
    medium_count = 0
try:
    if light_count is None:
        light_count = 0
except NameError:
    light_count = 0
tasks_classified = True
      </bpmn:script>
    </bpmn:scriptTask>

    <!-- STEP 2: ESTIMATE CONTEXT BUDGET -->
    <bpmn:scriptTask id="estimate_budget" name="[CLAUDE] Estimate Context Budget" scriptFormat="python">
      <bpmn:documentation>Calculate estimated token cost:
  estimated_tokens = heavy_count×800 + medium_count×400 + light_count×100
Compare against remaining budget with 40% safety margin:
  within_budget = estimated_tokens &lt; remaining_budget × 0.6
The safety margin prevents cutting it close - context exhaustion is catastrophic.</bpmn:documentation>
      <bpmn:incoming>flow_classify_to_estimate</bpmn:incoming>
      <bpmn:outgoing>flow_estimate_to_budget_gw</bpmn:outgoing>
      <bpmn:script>
try:
    if remaining_budget is None:
        remaining_budget = 50000
except NameError:
    remaining_budget = 50000
estimated_tokens = (heavy_count * 800) + (medium_count * 400) + (light_count * 100)
within_budget = estimated_tokens &lt; (remaining_budget * 0.6)
has_heavy_tasks = heavy_count > 0
      </bpmn:script>
    </bpmn:scriptTask>

    <!-- GATEWAY: WITHIN BUDGET? -->
    <bpmn:exclusiveGateway id="budget_gw" name="Within Budget?" default="flow_over_budget">
      <bpmn:incoming>flow_estimate_to_budget_gw</bpmn:incoming>
      <bpmn:outgoing>flow_within_budget</bpmn:outgoing>
      <bpmn:outgoing>flow_over_budget</bpmn:outgoing>
    </bpmn:exclusiveGateway>

    <!-- === PATH A: DIRECT EXECUTION (within budget) === -->
    <bpmn:scriptTask id="execute_with_checkpoints" name="[CLAUDE] Execute With Progressive Checkpoints" scriptFormat="python">
      <bpmn:documentation>Execute all tasks in current context, but save checkpoint after each.
Progressive checkpoints prevent total context loss even if we underestimated.
After each task: save_checkpoint(focus=current_task, progress_notes=completed_so_far).
This is the key difference from pre-crash behavior (no checkpoints at all).</bpmn:documentation>
      <bpmn:incoming>flow_within_budget</bpmn:incoming>
      <bpmn:outgoing>flow_direct_to_end</bpmn:outgoing>
      <bpmn:script>
execution_strategy = "direct_with_checkpoints"
checkpoints_enabled = True
      </bpmn:script>
    </bpmn:scriptTask>

    <!-- === PATH B+C: OVER BUDGET - CHOOSE STRATEGY === -->
    <bpmn:scriptTask id="choose_strategy" name="[CLAUDE] Choose Delegation Strategy" scriptFormat="python">
      <bpmn:documentation>Over budget. Choose strategy based on task mix:
- delegate_all: heavy tasks dominate, no point doing anything inline
- split_and_delegate: mix of light+heavy, do light inline, delegate heavy
- direct_with_checkpoints: no heavy tasks, just many medium ones (risky but manageable)
The presence of heavy tasks is the key decision factor.</bpmn:documentation>
      <bpmn:incoming>flow_over_budget</bpmn:incoming>
      <bpmn:outgoing>flow_strategy_to_gw</bpmn:outgoing>
      <bpmn:script>
if has_heavy_tasks and light_count == 0:
    strategy = "delegate_all"
elif has_heavy_tasks and light_count > 0:
    strategy = "split_and_delegate"
else:
    strategy = "direct_with_checkpoints"
      </bpmn:script>
    </bpmn:scriptTask>

    <!-- GATEWAY: WHICH STRATEGY? -->
    <bpmn:exclusiveGateway id="strategy_gw" name="Delegation Strategy?" default="flow_split">
      <bpmn:incoming>flow_strategy_to_gw</bpmn:incoming>
      <bpmn:outgoing>flow_delegate_all</bpmn:outgoing>
      <bpmn:outgoing>flow_split</bpmn:outgoing>
      <bpmn:outgoing>flow_direct_fallback</bpmn:outgoing>
    </bpmn:exclusiveGateway>

    <!-- === PATH B: DELEGATE ALL === -->
    <bpmn:scriptTask id="prepare_all_instructions" name="[CLAUDE] Prepare Agent Instructions (All Tasks)" scriptFormat="python">
      <bpmn:documentation>Create concise agent instructions for each task group.
CRITICAL: Minimize context transferred to agents:
- Only include relevant file paths and patterns
- Don't send full CLAUDE.md - extract relevant rules only
- Include exact acceptance criteria (how to verify)
- Group related tasks for the same agent (e.g., 2-3 BPMN models per agent)
Agent types: tester-haiku (tests), coder-haiku (simple), coder-sonnet (complex).</bpmn:documentation>
      <bpmn:incoming>flow_delegate_all</bpmn:incoming>
      <bpmn:outgoing>flow_prep_all_to_checkpoint</bpmn:outgoing>
      <bpmn:script>
instructions_prepared = True
      </bpmn:script>
    </bpmn:scriptTask>

    <bpmn:scriptTask id="checkpoint_before_delegate" name="[MCP] Save Checkpoint Before Delegation" scriptFormat="python">
      <bpmn:documentation>Save state before spawning agents:
- store_session_fact: what's being delegated, expected outcomes
- save_checkpoint: current progress, which tasks are delegated
- store_session_notes: agent task assignments for recovery
This ensures we can resume even if main context is lost during collection.</bpmn:documentation>
      <bpmn:incoming>flow_prep_all_to_checkpoint</bpmn:incoming>
      <bpmn:outgoing>flow_checkpoint_to_spawn</bpmn:outgoing>
      <bpmn:script>
checkpoint_saved = True
      </bpmn:script>
    </bpmn:scriptTask>

    <bpmn:scriptTask id="spawn_agents" name="[CLAUDE] Spawn Agents in Parallel" scriptFormat="python">
      <bpmn:documentation>Spawn agents using Task tool or orchestrator.spawn_agent.
Rules:
- Max 3-4 concurrent agents (diminishing returns beyond that)
- Each agent gets 2-3 related tasks (not 1 each - too much overhead)
- Use background mode for truly independent work
- Use foreground for work that feeds next steps
Agent selection: tester-haiku for tests, coder-haiku for simple code, coder-sonnet for complex.</bpmn:documentation>
      <bpmn:incoming>flow_checkpoint_to_spawn</bpmn:incoming>
      <bpmn:outgoing>flow_spawn_to_collect</bpmn:outgoing>
      <bpmn:script>
agents_spawned = True
      </bpmn:script>
    </bpmn:scriptTask>

    <!-- === PATH C: SPLIT AND DELEGATE === -->
    <bpmn:scriptTask id="execute_light_tasks" name="[CLAUDE] Execute Light Tasks Directly" scriptFormat="python">
      <bpmn:documentation>Execute the light/medium tasks that fit in current context.
Save checkpoint after each completed task.
This keeps main context productive while agents handle heavy work.</bpmn:documentation>
      <bpmn:incoming>flow_split</bpmn:incoming>
      <bpmn:outgoing>flow_light_to_checkpoint</bpmn:outgoing>
      <bpmn:script>
light_tasks_executed = True
      </bpmn:script>
    </bpmn:scriptTask>

    <bpmn:scriptTask id="checkpoint_before_heavy" name="[MCP] Save Checkpoint Before Heavy Delegation" scriptFormat="python">
      <bpmn:documentation>Save progress from light tasks + prepare for heavy delegation.
Includes: completed task list, remaining heavy tasks, agent assignments.</bpmn:documentation>
      <bpmn:incoming>flow_light_to_checkpoint</bpmn:incoming>
      <bpmn:outgoing>flow_checkpoint_to_prep</bpmn:outgoing>
      <bpmn:script>
checkpoint_saved = True
      </bpmn:script>
    </bpmn:scriptTask>

    <bpmn:scriptTask id="prepare_heavy_instructions" name="[CLAUDE] Prepare Agent Instructions (Heavy Tasks)" scriptFormat="python">
      <bpmn:documentation>Create agent instructions for heavy tasks only.
Same rules as prepare_all_instructions but scoped to heavy tasks.</bpmn:documentation>
      <bpmn:incoming>flow_checkpoint_to_prep</bpmn:incoming>
      <bpmn:outgoing>flow_prep_heavy_to_spawn</bpmn:outgoing>
      <bpmn:script>
instructions_prepared = True
      </bpmn:script>
    </bpmn:scriptTask>

    <bpmn:scriptTask id="spawn_heavy_agents" name="[CLAUDE] Spawn Agents for Heavy Tasks" scriptFormat="python">
      <bpmn:documentation>Spawn agents for heavy tasks. Same rules as spawn_agents.</bpmn:documentation>
      <bpmn:incoming>flow_prep_heavy_to_spawn</bpmn:incoming>
      <bpmn:outgoing>flow_heavy_spawn_to_collect</bpmn:outgoing>
      <bpmn:script>
agents_spawned = True
      </bpmn:script>
    </bpmn:scriptTask>

    <!-- === SHARED: COLLECT AND VERIFY === -->
    <bpmn:scriptTask id="collect_and_verify" name="[CLAUDE] Collect and Verify Agent Results" scriptFormat="python">
      <bpmn:documentation>Wait for agent completion, then verify:
1. Read TaskOutput for each agent
2. Run tests (pytest for BPMN, unit tests for code)
3. Check files exist and are well-formed
4. If verification fails: fix inline if simple, re-delegate if complex
5. Clean up any agent artifacts (doc files, temp scripts)
This is where agent doc spam gets caught and removed.</bpmn:documentation>
      <bpmn:incoming>flow_spawn_to_collect</bpmn:incoming>
      <bpmn:incoming>flow_heavy_spawn_to_collect</bpmn:incoming>
      <bpmn:outgoing>flow_collect_to_end</bpmn:outgoing>
      <bpmn:script>
results_verified = True
      </bpmn:script>
    </bpmn:scriptTask>

    <!-- === PATH B2: DIRECT FALLBACK (over budget but no heavy tasks) === -->
    <bpmn:scriptTask id="execute_direct_fallback" name="[CLAUDE] Execute Directly With Aggressive Checkpoints" scriptFormat="python">
      <bpmn:documentation>Over budget but all tasks are medium/light - no heavy tasks worth delegating.
Execute directly but with aggressive checkpointing (every 2-3 tasks).
If context starts running low, stop and save state for next session.</bpmn:documentation>
      <bpmn:incoming>flow_direct_fallback</bpmn:incoming>
      <bpmn:outgoing>flow_fallback_to_end</bpmn:outgoing>
      <bpmn:script>
execution_strategy = "direct_aggressive_checkpoints"
checkpoints_enabled = True
      </bpmn:script>
    </bpmn:scriptTask>

    <!-- END -->
    <bpmn:endEvent id="end_complete" name="Batch Execution Complete">
      <bpmn:incoming>flow_direct_to_end</bpmn:incoming>
      <bpmn:incoming>flow_collect_to_end</bpmn:incoming>
      <bpmn:incoming>flow_fallback_to_end</bpmn:incoming>
    </bpmn:endEvent>

    <!-- === SEQUENCE FLOWS === -->
    <bpmn:sequenceFlow id="flow_start_to_classify" sourceRef="start" targetRef="classify_tasks"/>
    <bpmn:sequenceFlow id="flow_classify_to_estimate" sourceRef="classify_tasks" targetRef="estimate_budget"/>
    <bpmn:sequenceFlow id="flow_estimate_to_budget_gw" sourceRef="estimate_budget" targetRef="budget_gw"/>

    <!-- Within budget → direct -->
    <bpmn:sequenceFlow id="flow_within_budget" sourceRef="budget_gw" targetRef="execute_with_checkpoints">
      <bpmn:conditionExpression>within_budget == True</bpmn:conditionExpression>
    </bpmn:sequenceFlow>
    <bpmn:sequenceFlow id="flow_over_budget" sourceRef="budget_gw" targetRef="choose_strategy"/>
    <bpmn:sequenceFlow id="flow_direct_to_end" sourceRef="execute_with_checkpoints" targetRef="end_complete"/>

    <!-- Strategy decision -->
    <bpmn:sequenceFlow id="flow_strategy_to_gw" sourceRef="choose_strategy" targetRef="strategy_gw"/>

    <!-- Delegate all path -->
    <bpmn:sequenceFlow id="flow_delegate_all" sourceRef="strategy_gw" targetRef="prepare_all_instructions">
      <bpmn:conditionExpression>strategy == "delegate_all"</bpmn:conditionExpression>
    </bpmn:sequenceFlow>
    <bpmn:sequenceFlow id="flow_prep_all_to_checkpoint" sourceRef="prepare_all_instructions" targetRef="checkpoint_before_delegate"/>
    <bpmn:sequenceFlow id="flow_checkpoint_to_spawn" sourceRef="checkpoint_before_delegate" targetRef="spawn_agents"/>
    <bpmn:sequenceFlow id="flow_spawn_to_collect" sourceRef="spawn_agents" targetRef="collect_and_verify"/>

    <!-- Split and delegate path -->
    <bpmn:sequenceFlow id="flow_split" sourceRef="strategy_gw" targetRef="execute_light_tasks">
      <bpmn:conditionExpression>strategy == "split_and_delegate"</bpmn:conditionExpression>
    </bpmn:sequenceFlow>
    <bpmn:sequenceFlow id="flow_light_to_checkpoint" sourceRef="execute_light_tasks" targetRef="checkpoint_before_heavy"/>
    <bpmn:sequenceFlow id="flow_checkpoint_to_prep" sourceRef="checkpoint_before_heavy" targetRef="prepare_heavy_instructions"/>
    <bpmn:sequenceFlow id="flow_prep_heavy_to_spawn" sourceRef="prepare_heavy_instructions" targetRef="spawn_heavy_agents"/>
    <bpmn:sequenceFlow id="flow_heavy_spawn_to_collect" sourceRef="spawn_heavy_agents" targetRef="collect_and_verify"/>

    <!-- Direct fallback path (over budget but no heavy tasks) -->
    <bpmn:sequenceFlow id="flow_direct_fallback" sourceRef="strategy_gw" targetRef="execute_direct_fallback">
      <bpmn:conditionExpression>strategy == "direct_with_checkpoints"</bpmn:conditionExpression>
    </bpmn:sequenceFlow>
    <bpmn:sequenceFlow id="flow_fallback_to_end" sourceRef="execute_direct_fallback" targetRef="end_complete"/>

  </bpmn:process>

  <bpmndi:BPMNDiagram id="BPMNDiagram_1">
    <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="context_budget_management">
      <bpmndi:BPMNShape id="s_start" bpmnElement="start">
        <dc:Bounds x="50" y="300" width="36" height="36"/>
      </bpmndi:BPMNShape>
    </bpmndi:BPMNPlane>
  </bpmndi:BPMNDiagram>

</bpmn:definitions>
