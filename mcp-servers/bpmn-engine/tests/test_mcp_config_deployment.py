"""
Tests for the MCP Config Deployment BPMN process (L2_mcp_config_deployment).

Models the two-tier MCP configuration system used by start-claude.bat.

Tier 1 - Global (~/.claude/mcp.json):
  Manually maintained. Always available to all Claude sessions. Not DB-driven.

Tier 2 - Project ({project}/.mcp.json):
  DB-driven via claude.workspaces.startup_config.mcp_configs.
  Generated by scripts/generate_mcp_config.py on every project launch.

Single start event routes via flow_type:
  flow_type="launch"     -> launcher flow (start-claude.bat)
  flow_type="add_remove" -> add/remove MCP sub-process (default)

Flow A - Launcher (flow_type="launch"):
  start -> route_gw [launch]
        -> select_project [user]
        -> read_workspace_config
        -> has_mcp_configs_gw
             [yes] -> generate_mcp_json -> resolve_npx_paths -> write_mcp_json
             [no]  -> skip_mcp_generation
        -> deploy_other_configs -> launch_claude -> load_mcp_configs -> end_launched

Flow B - Add/Remove MCP (flow_type="add_remove" / default):
  start -> route_gw [default]
        -> scope_gw
             [global]  -> edit_global_mcp_json [user] -> audit_merge_gw
             [project] -> update_db_mcp_configs -> regenerate_project_mcp -> audit_merge_gw
        -> record_audit -> end_mcp_changed

Key API notes (SpiffWorkflow 3.1.x):
  - BpmnParser.add_bpmn_file(path) + parser.get_spec(process_id)
  - BpmnWorkflow(spec) creates the workflow instance
  - workflow.do_engine_steps() advances through non-manual tasks (scripts, gateways)
  - User tasks: workflow.get_tasks(state=TaskState.READY, manual=True)
  - task.data is a dict; set values before task.run() to influence downstream conditions
  - Gateway conditions are Python expressions eval'd against task.data
"""

import os

from SpiffWorkflow.bpmn.workflow import BpmnWorkflow
from SpiffWorkflow.bpmn.parser import BpmnParser
from SpiffWorkflow.util.task import TaskState

BPMN_FILE = os.path.abspath(
    os.path.join(
        os.path.dirname(__file__),
        "..",
        "processes",
        "infrastructure",
        "mcp_config_deployment.bpmn",
    )
)
PROCESS_ID = "L2_mcp_config_deployment"


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _load_workflow(initial_data: dict = None) -> BpmnWorkflow:
    """Parse the BPMN and return a workflow instance seeded with initial_data.

    Data seeded via initial_data is placed on the READY start event task
    so it propagates to all downstream tasks during do_engine_steps().
    """
    parser = BpmnParser()
    parser.add_bpmn_file(BPMN_FILE)
    spec = parser.get_spec(PROCESS_ID)
    wf = BpmnWorkflow(spec)

    if initial_data:
        ready = wf.get_tasks(state=TaskState.READY)
        for task in ready:
            task.data.update(initial_data)

    wf.do_engine_steps()
    return wf


def _get_ready_user_tasks(workflow: BpmnWorkflow) -> list:
    """Return all READY user tasks."""
    return workflow.get_tasks(state=TaskState.READY, manual=True)


def _complete_user_task(workflow: BpmnWorkflow, task_name: str, data: dict) -> None:
    """Find the named READY user task, merge data, run it, then advance the engine."""
    ready = _get_ready_user_tasks(workflow)
    matches = [t for t in ready if t.task_spec.name == task_name]
    assert matches, (
        f"Expected user task '{task_name}' to be READY. "
        f"READY user tasks: {[t.task_spec.name for t in ready]}"
    )
    task = matches[0]
    task.data.update(data)
    task.run()
    workflow.do_engine_steps()


def _completed_names(workflow: BpmnWorkflow) -> list:
    """Return spec names of all COMPLETED tasks."""
    return [t.task_spec.name for t in workflow.get_tasks(state=TaskState.COMPLETED)]


def _base_launcher_data(**overrides) -> dict:
    """Seed data to enter the launcher flow (Flow A)."""
    data = {
        "flow_type": "launch",
        "project_name": "claude-family",
        "project_path": "C:/Projects/claude-family",
        "mcp_configs": None,
    }
    data.update(overrides)
    return data


def _base_add_remove_data(**overrides) -> dict:
    """Seed data to enter the add/remove MCP sub-process (Flow B)."""
    data = {
        "flow_type": "add_remove",
        "mcp_scope": "project",
        "mcp_server_name": "my-server",
        "mcp_action": "add",
        "project_name": "claude-family",
        "mcp_server_config": {"command": "node", "args": ["server.js"]},
    }
    data.update(overrides)
    return data


# ---------------------------------------------------------------------------
# Flow A Tests: Launcher Flow (start-claude.bat)
# ---------------------------------------------------------------------------


class TestLauncherHappyPathWithMcpConfigs:
    """
    Project WITH mcp_configs in DB -> .mcp.json generated.

    Path: start -> route_gw [launch]
               -> select_project [user]
               -> read_workspace_config
               -> has_mcp_configs_gw [yes]
               -> generate_mcp_json -> resolve_npx_paths -> write_mcp_json
               -> deploy_other_configs -> launch_claude -> load_mcp_configs -> end_launched
    """

    def test_mcp_json_generated_when_configs_present(self):
        wf = _load_workflow(_base_launcher_data())

        # Stops at the user task (select_project)
        assert not wf.is_completed()
        ready_names = [t.task_spec.name for t in _get_ready_user_tasks(wf)]
        assert "select_project" in ready_names, (
            f"Expected select_project, got: {ready_names}"
        )

        # User selects a project that has mcp_configs
        _complete_user_task(wf, "select_project", {
            "project_name": "claude-family",
            "project_path": "C:/Projects/claude-family",
            "mcp_configs": [
                {"name": "nimbus-knowledge", "command": "npx", "args": ["-y", "@nimbus/mcp-server"]},
                {"name": "mui", "command": "node", "args": ["C:/tools/mui-server/index.js"]},
            ],
        })

        assert wf.is_completed(), "Workflow should complete after launcher sequence"

        names = _completed_names(wf)

        # Route to launcher
        assert "route_gw" in names

        # Full generation path executed
        assert "select_project" in names
        assert "read_workspace_config" in names
        assert "generate_mcp_json" in names
        assert "resolve_npx_paths" in names
        assert "write_mcp_json" in names
        assert "deploy_other_configs" in names
        assert "launch_claude" in names
        assert "load_mcp_configs" in names
        assert "end_launched" in names

        # Skip branch NOT taken
        assert "skip_mcp_generation" not in names

        # Add/remove flow NOT taken
        assert "scope_gw" not in names
        assert "record_audit" not in names

        # Output data
        assert wf.data.get("mcp_json_written") is True
        assert wf.data.get("paths_resolved") is True
        assert wf.data.get("other_configs_deployed") is True
        assert wf.data.get("claude_launched") is True
        assert wf.data.get("global_mcps_loaded") is True
        assert wf.data.get("project_mcps_loaded") is True
        assert wf.data.get("server_count") == 2

    def test_npx_commands_resolved_to_cmd_wrapper(self):
        """npx entries are rewritten to cmd /c node for Windows compatibility."""
        wf = _load_workflow(_base_launcher_data())

        _complete_user_task(wf, "select_project", {
            "project_name": "test-project",
            "project_path": "C:/Projects/test",
            "mcp_configs": [
                {"name": "tool-a", "command": "npx", "args": ["-y", "@tool/server"]},
            ],
        })

        assert wf.is_completed()
        assert wf.data.get("paths_resolved") is True

        resolved = wf.data.get("resolved_mcp_entries", [])
        assert len(resolved) == 1
        # npx command was rewritten to cmd
        assert resolved[0]["command"] == "cmd"
        assert resolved[0].get("_resolved") is True

    def test_non_npx_commands_pass_through_unchanged(self):
        """node commands are not transformed by resolve_npx_paths."""
        wf = _load_workflow(_base_launcher_data())

        _complete_user_task(wf, "select_project", {
            "project_name": "test-project",
            "project_path": "C:/Projects/test",
            "mcp_configs": [
                {"name": "direct-server", "command": "node", "args": ["index.js"]},
            ],
        })

        assert wf.is_completed()

        resolved = wf.data.get("resolved_mcp_entries", [])
        assert len(resolved) == 1
        # node command passed through unchanged
        assert resolved[0]["command"] == "node"
        assert resolved[0].get("_resolved") is None


class TestLauncherSkipPathWithoutMcpConfigs:
    """
    Project WITHOUT mcp_configs in DB -> skip .mcp.json generation.

    Path: start -> route_gw [launch]
               -> select_project [user]
               -> read_workspace_config
               -> has_mcp_configs_gw [no - default]
               -> skip_mcp_generation
               -> deploy_other_configs -> launch_claude -> load_mcp_configs -> end_launched
    """

    def test_mcp_json_skipped_when_no_configs(self):
        wf = _load_workflow(_base_launcher_data())

        assert not wf.is_completed()

        # User selects a project with no mcp_configs (None)
        _complete_user_task(wf, "select_project", {
            "project_name": "simple-project",
            "project_path": "C:/Projects/simple",
            "mcp_configs": None,
        })

        assert wf.is_completed()

        names = _completed_names(wf)

        # Skip branch taken
        assert "skip_mcp_generation" in names
        assert "deploy_other_configs" in names
        assert "launch_claude" in names
        assert "load_mcp_configs" in names
        assert "end_launched" in names

        # Generation branch NOT taken
        assert "generate_mcp_json" not in names
        assert "resolve_npx_paths" not in names
        assert "write_mcp_json" not in names

        # Data: only global MCPs loaded (Tier 1 only)
        assert wf.data.get("mcp_json_written") is False
        assert wf.data.get("mcp_generation_skipped") is True
        assert wf.data.get("global_mcps_loaded") is True
        assert wf.data.get("project_mcps_loaded") is False
        assert wf.data.get("server_count") == 0

        # Only global tier in merged registry
        merged = wf.data.get("merged_mcp_registry", [])
        assert "global_mcps" in merged
        assert "project_mcps" not in merged

    def test_empty_mcp_configs_list_skips_generation(self):
        """An empty list [] is treated as falsy and triggers the skip branch."""
        wf = _load_workflow(_base_launcher_data())

        _complete_user_task(wf, "select_project", {
            "project_name": "another-project",
            "project_path": "C:/Projects/another",
            "mcp_configs": [],
        })

        assert wf.is_completed()

        names = _completed_names(wf)
        assert "skip_mcp_generation" in names
        assert "generate_mcp_json" not in names
        assert wf.data.get("mcp_generation_skipped") is True


class TestLauncherMcpJsonPath:
    """Verify the .mcp.json output path is constructed correctly."""

    def test_mcp_json_path_is_project_root(self):
        wf = _load_workflow(_base_launcher_data())

        _complete_user_task(wf, "select_project", {
            "project_name": "myproject",
            "project_path": "C:/Projects/myproject",
            "mcp_configs": [{"name": "server-a", "command": "node", "args": ["index.js"]}],
        })

        assert wf.is_completed()
        assert wf.data.get("mcp_json_path") == "C:/Projects/myproject/.mcp.json"


class TestLauncherConfigDeployment:
    """Verify other configs are always deployed regardless of MCP config path taken."""

    def test_settings_and_claude_md_always_deployed(self):
        """Both configs-present and configs-absent paths deploy settings + CLAUDE.md."""
        for has_mcp in [True, False]:
            wf = _load_workflow(_base_launcher_data())
            _complete_user_task(wf, "select_project", {
                "project_path": "C:/Projects/test",
                "mcp_configs": [{"name": "s", "command": "node", "args": []}] if has_mcp else None,
            })

            assert wf.is_completed()
            assert wf.data.get("other_configs_deployed") is True
            assert wf.data.get("settings_deployed") is True
            assert wf.data.get("claude_md_deployed") is True


# ---------------------------------------------------------------------------
# Flow B Tests: Add/Remove MCP Server Sub-Process
# ---------------------------------------------------------------------------


class TestAddGlobalMcpServer:
    """
    Adding a GLOBAL MCP server (Tier 1) requires manual file edit.

    Path: start -> route_gw [default]
               -> scope_gw [global]
               -> edit_global_mcp_json [user]
               -> audit_merge_gw -> record_audit -> end_mcp_changed
    """

    def test_add_global_mcp_requires_user_task(self):
        wf = _load_workflow(_base_add_remove_data(mcp_scope="global"))

        # Engine stops at the manual user task
        assert not wf.is_completed()
        ready_names = [t.task_spec.name for t in _get_ready_user_tasks(wf)]
        assert "edit_global_mcp_json" in ready_names, (
            f"Expected edit_global_mcp_json, got: {ready_names}"
        )

        # User manually edits ~/.claude/mcp.json
        _complete_user_task(wf, "edit_global_mcp_json", {
            "global_mcp_edit_done": True,
        })

        assert wf.is_completed()

        names = _completed_names(wf)

        # Global path executed
        assert "scope_gw" in names
        assert "edit_global_mcp_json" in names
        assert "audit_merge_gw" in names
        assert "record_audit" in names
        assert "end_mcp_changed" in names

        # Project branch NOT taken
        assert "update_db_mcp_configs" not in names
        assert "regenerate_project_mcp" not in names

        # Launcher flow NOT taken
        assert "select_project" not in names
        assert "end_launched" not in names

        # Audit data
        assert wf.data.get("audit_recorded") is True
        assert wf.data.get("tier") == "global"

    def test_remove_global_mcp_follows_same_path(self):
        """Removing a global MCP follows the identical manual-edit path."""
        wf = _load_workflow(_base_add_remove_data(
            mcp_scope="global",
            mcp_action="remove",
            mcp_server_name="old-server",
        ))

        assert not wf.is_completed()
        _complete_user_task(wf, "edit_global_mcp_json", {"global_mcp_edit_done": True})

        assert wf.is_completed()
        assert wf.data.get("audit_recorded") is True
        assert wf.data.get("tier") == "global"


class TestAddProjectMcpServer:
    """
    Adding a PROJECT-SPECIFIC MCP server (Tier 2) is DB-driven and fully automated.

    Path: start -> route_gw [default]
               -> scope_gw [project - default]
               -> update_db_mcp_configs -> regenerate_project_mcp
               -> audit_merge_gw -> record_audit -> end_mcp_changed
    """

    def test_add_project_mcp_is_fully_automated(self):
        wf = _load_workflow(_base_add_remove_data(mcp_scope="project"))

        # Project scope is fully automated (no user tasks)
        assert wf.is_completed(), "Project MCP path should complete without user tasks"

        names = _completed_names(wf)

        # Project path executed
        assert "scope_gw" in names
        assert "update_db_mcp_configs" in names
        assert "regenerate_project_mcp" in names
        assert "audit_merge_gw" in names
        assert "record_audit" in names
        assert "end_mcp_changed" in names

        # Global path NOT taken
        assert "edit_global_mcp_json" not in names

        # Launcher flow NOT taken
        assert "select_project" not in names

        # Data
        assert wf.data.get("db_mcp_configs_updated") is True
        assert wf.data.get("mcp_json_regenerated") is True
        assert wf.data.get("audit_recorded") is True
        assert wf.data.get("tier") == "project"

    def test_remove_project_mcp_follows_same_db_path(self):
        """Removing a project MCP follows the same DB-driven path."""
        wf = _load_workflow(_base_add_remove_data(
            mcp_scope="project",
            mcp_action="remove",
            mcp_server_name="nimbus-knowledge",
        ))

        assert wf.is_completed()

        names = _completed_names(wf)
        assert "update_db_mcp_configs" in names
        assert "regenerate_project_mcp" in names
        assert wf.data.get("audit_recorded") is True

    def test_default_scope_routes_to_project(self):
        """
        No mcp_scope seeded -> route_gw default fires -> scope_gw default fires -> project path.
        """
        wf = _load_workflow({
            # flow_type not set -> add_remove default fires
            # mcp_scope not set -> project default fires
            "mcp_server_name": "test-server",
            "mcp_action": "add",
            "project_name": "test",
        })

        assert wf.is_completed()

        names = _completed_names(wf)
        # Default route: add_remove -> project scope
        assert "update_db_mcp_configs" in names
        assert "regenerate_project_mcp" in names
        assert "edit_global_mcp_json" not in names
        assert "select_project" not in names


# ---------------------------------------------------------------------------
# End-to-End Launcher Flow Test
# ---------------------------------------------------------------------------


class TestFullLauncherFlow:
    """
    End-to-end test of the full launcher flow as executed by start-claude.bat.

    Simulates a production scenario where:
    1. User selects a project with multiple MCP server configs in DB
    2. .mcp.json is generated with npx paths resolved
    3. Other configs (settings.local.json, CLAUDE.md) deployed
    4. Claude launched with both Tier 1 (global) + Tier 2 (project) MCPs
    """

    def test_full_launch_with_project_mcps(self):
        wf = _load_workflow(_base_launcher_data(
            project_name="nimbus-ai-platform",
            project_path="C:/Projects/nimbus-ai-platform",
        ))

        # Phase 1: User task stops the flow
        assert not wf.is_completed()
        assert "select_project" in [t.task_spec.name for t in _get_ready_user_tasks(wf)]

        # Phase 2: User selects project with dedicated MCPs
        _complete_user_task(wf, "select_project", {
            "project_name": "nimbus-ai-platform",
            "project_path": "C:/Projects/nimbus-ai-platform",
            "mcp_configs": [
                {
                    "name": "nimbus-knowledge",
                    "command": "npx",
                    "args": ["-y", "@nimbus/knowledge-server"],
                    "env": {"NIMBUS_DB_URL": "postgresql://localhost/nimbus"},
                },
                {
                    "name": "mui",
                    "command": "node",
                    "args": ["C:/tools/mui-server/dist/index.js"],
                    "env": {},
                },
            ],
        })

        # Phase 3: Verify full completion
        assert wf.is_completed()

        names = _completed_names(wf)

        # All launcher stages completed
        assert "route_gw" in names
        assert "select_project" in names
        assert "read_workspace_config" in names
        assert "generate_mcp_json" in names
        assert "resolve_npx_paths" in names
        assert "write_mcp_json" in names
        assert "deploy_other_configs" in names
        assert "launch_claude" in names
        assert "load_mcp_configs" in names
        assert "end_launched" in names

        # Correct terminal state
        assert "end_mcp_changed" not in names

        # Final data state
        assert wf.data.get("claude_launched") is True
        assert wf.data.get("global_mcps_loaded") is True
        assert wf.data.get("project_mcps_loaded") is True
        assert wf.data.get("mcp_json_written") is True
        assert wf.data.get("other_configs_deployed") is True
        assert wf.data.get("settings_deployed") is True
        assert wf.data.get("claude_md_deployed") is True
        # 2 servers configured
        assert wf.data.get("server_count") == 2
        # Both tiers in merged registry
        merged = wf.data.get("merged_mcp_registry", [])
        assert "global_mcps" in merged
        assert "project_mcps" in merged

    def test_full_launch_global_only(self):
        """
        Project with no mcp_configs in DB - only global Tier 1 MCPs available after launch.
        """
        wf = _load_workflow(_base_launcher_data(project_name="minimal-project"))

        _complete_user_task(wf, "select_project", {
            "project_name": "minimal-project",
            "project_path": "C:/Projects/minimal",
            "mcp_configs": None,
        })

        assert wf.is_completed()

        names = _completed_names(wf)
        assert "skip_mcp_generation" in names
        assert "end_launched" in names
        assert "end_mcp_changed" not in names

        merged = wf.data.get("merged_mcp_registry", [])
        assert "global_mcps" in merged
        assert "project_mcps" not in merged
